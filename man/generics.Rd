% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/generics.R
\name{augment}
\alias{augment}
\alias{compile}
\alias{estfun}
\alias{evaluate}
\alias{explain}
\alias{find_varying}
\alias{fit}
\alias{glance}
\alias{learn}
\alias{prune}
\alias{refit}
\alias{tidy}
\alias{train}
\alias{var_imp}
\title{Generic functions related to modeling}
\usage{
augment(x, ...)

compile(object, ...)

estfun(x, ...)

evaluate(x, ...)

explain(x, ...)

find_varying(object, ...)

fit(object, ...)

glance(x, ...)

learn(x, ...)

prune(tree, ...)

refit(object, ...)

tidy(x, ...)

train(x, ...)

var_imp(object, ...)
}
\arguments{
\item{...}{Additional arguments to pass to other functions.}

\item{object, x}{An object. See Details below.}

\item{tree}{A fitted model object.}
}
\description{
These are generic functions that can be used to minimize
package dependencies when multiple packages have the same
method.
}
\details{
An attempt was made to use generic class signatures that were
consistent with existing code. For example, \pkg{dplyr} and
\pkg{lime} both have \code{explain} methods that do very different
things but both take \code{x} as their main object. Even though \code{x}
would be different in those cases, this package provides access
to the S3 generic so that other packages that may want to create
\code{explain} methods for their objects can do so without loading
either of the other packages.

For example, if a new \code{tidy} method is being developed for a
package, this lightweight package can be the required dependency
to have access to the generic method (instead of depending on
\pkg{broom} and installing its dependencies).

Known functions related to modeling (which may or may not be
consistent with the definitions in this package) include:
\itemize{
\item \code{augment}: \pkg{broom}
\item \code{compile}: \pkg{keras}, \pkg{tensorflow}
\item \code{estfun}: \pkg{sandwich}, \pkg{ssym}, \pkg{gmm}, \pkg{maxLik},
\pkg{psychotools}, \pkg{drc}, and others
\item \code{evaluate}: \pkg{keras}, \pkg{tensorflow}, \pkg{healthcareai}
\item \code{explain}: \pkg{dplyr}, \pkg{lime}, \pkg{DALEX}
\item \code{find_varying}: used by the development versions of \pkg{parsnip} and
\pkg{recipes}
\item \code{fit}: \pkg{keras}
\item \code{glance}: \pkg{broom}
\item \code{learn}: \pkg{grnn}, \pkg{pnn}
\item \code{prune}: \pkg{rpart}, \pkg{dendextend}
\item \code{refit}: \pkg{modeltools}, \pkg{lmSubsets}, \pkg{partykit},
\pkg{glogis}, \pkg{fxregime}, and others.
\item \code{tidy}: \pkg{broom}, \pkg{estimatr}, \pkg{radiant.data},
\pkg{permutations}, and others.
\item \code{train}: \pkg{caret}, \pkg{tensorflow}, \pkg{mlr}, \pkg{RSNNS},
\pkg{Information}, and others.
\item \code{var_imp}: \pkg{datafsm}
}

It is suggested that, if a package uses \pkg{modelgenerics}, it
do so by \emph{importing} the package and re-exporting the method
of interest. For example, if the \code{explain} method were being
used, the roxygen2 code to do this would be

\preformatted{
    #' @importFrom modelgenerics explain
    #' @export
    modelgenerics::explain
}

This will help avoid collisions with methods contained in
this package and others.
}
\examples{
fit

tidy

}
